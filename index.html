<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syrus's Lan Party</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222; /* Darker background */
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<script>
    let drops = [];
    let numDrops = 600; // Increased number of drops
    let windSpeed = 1;
    let gravity = 0.5;
    let baseLength = 8;
    let lengthVariation = 6;
    let baseSpeed = 4;
    let speedVariation = 2;
    let baseWeight = 1;
    let weightVariation = 1;
    let floodHeight = 0;
    let flooding = false;
    let floodSpeed = 2;
    let floodDelay = 10000; // 10 seconds
    let floodDuration = 10000; // 10 seconds
    let startTime;
    let floodTimer;
    let isFlushing = false; //track the flushing state
    let flushSpeed = 5;
    let waveFrequency = 0.02; // Adjust for wave frequency
    let waveAmplitude = 10; // Adjust for wave amplitude
    let wavePhase = 0; //initial phase of the wave

    function setup() {
        createCanvas(windowWidth, windowHeight);
        colorMode(HSB, 255);
        initializeRain();
        startTime = millis(); // Store start time
    }

    function initializeRain() {
        drops = [];
        for (let i = 0; i < numDrops; i++) {
            drops.push(new Drop());
        }
        floodHeight = 0; //reset flood height
        isFlushing = false;
        wavePhase = 0; // Reset wave phase
    }

    function draw() {
        background(230, 20, 30, 20); // Darker, slightly reddish background with low alpha for trails
        // Draw drops
        for (let i = 0; i < drops.length; i++) {
            drops[i].update();
            drops[i].show();
        }

        //check for flood
        if (millis() - startTime > floodDelay && !flooding && !isFlushing) {
            flooding = true;
            floodTimer = millis();
        }

        //handle flood
        if (flooding) {
            floodHeight += floodSpeed;
            if (floodHeight >= height / 2) {
                floodHeight = height / 2;
                flooding = false;
                isFlushing = true; //start flush
                floodTimer = millis(); //reset timer for flush
            }
        }

        //handle flush
        if(isFlushing){
            floodHeight -= flushSpeed;
            if(floodHeight <= 0){
                floodHeight = 0;
                isFlushing = false;
                startTime = millis(); //restart delay before next flood
            }
        }

        //draw water
        if (floodHeight > 0) {
            // fill(160, 100, 70, 150); // Semi-transparent blue
            //rect(0, height - floodHeight, width, floodHeight);

            // Wave effect
            wavePhase += 0.05; //update wave phase
            let waveDisplacement = sin(wavePhase) * waveAmplitude;
            fill(160, 100, 70, 150);  // Semi-transparent blue
            beginShape();
            for (let x = 0; x <= width; x += 10) {
                let y = height - floodHeight + sin(x * waveFrequency + wavePhase) * waveAmplitude;
                vertex(x, y);
            }
            vertex(width, height);
            vertex(0, height);
            endShape(CLOSE);
        }
    }

    class Drop {
        constructor() {
            this.x = random(width);
            this.y = random(height);
            this.z = random(0, 100); // Z-depth for perspective
            this.len = baseLength + random(-lengthVariation, lengthVariation);
            this.speed = baseSpeed + random(-speedVariation, speedVariation);
            this.weight = baseWeight + random(-weightVariation, weightVariation);
            this.color = color(180 + random(-30, 30), 100, 100, 180); // Varying hue, high saturation, medium brightness, high alpha
        }

        update() {
            this.y += this.speed * this.weight;
            this.x += windSpeed * this.weight;
            if (this.y > height) {
                this.y = random(-height, -height / 2);
                this.x = random(width);
            }
            if (this.x > width) {
                this.x = 0;
            }
            if (this.x < 0) {
                this.x = width;
            }
        }

        show() {
            let sw = map(this.weight, baseWeight, baseWeight + weightVariation, 1, 3); // Map weight to stroke width
            strokeWeight(sw);
            stroke(this.color);
            line(this.x, this.y, this.x, this.y + this.len);
        }
    }
</script>
</body>
</html>
